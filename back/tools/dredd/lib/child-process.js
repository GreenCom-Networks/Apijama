// Generated by CoffeeScript 1.12.5
var ASCII_CTRL_C, IS_WINDOWS, TERM_DEFAULT_RETRY_MS, TERM_DEFAULT_TIMEOUT_MS, TERM_FIRST_CHECK_TIMEOUT_MS, crossSpawn, signalKill, signalTerm, spawn, terminate,
  slice = [].slice;

crossSpawn = require('cross-spawn');

IS_WINDOWS = process.platform === 'win32';

ASCII_CTRL_C = 3;

TERM_FIRST_CHECK_TIMEOUT_MS = 1;

TERM_DEFAULT_TIMEOUT_MS = 1000;

TERM_DEFAULT_RETRY_MS = 300;

signalKill = function(childProcess, callback) {
  var taskkill;
  childProcess.emit('signalKill');
  if (IS_WINDOWS) {
    taskkill = spawn('taskkill', ['/F', '/T', '/PID', childProcess.pid]);
    return taskkill.on('exit', function(exitStatus) {
      var err;
      if (exitStatus) {
        err = new Error("Unable to forcefully terminate process " + childProcess.pid);
        return callback(err);
      }
      return callback();
    });
  } else {
    childProcess.kill('SIGKILL');
    return process.nextTick(callback);
  }
};

signalTerm = function(childProcess, callback) {
  childProcess.emit('signalTerm');
  if (IS_WINDOWS) {
    childProcess.stdin.write(String.fromCharCode(ASCII_CTRL_C));
  } else {
    childProcess.kill('SIGTERM');
  }
  return process.nextTick(callback);
};

terminate = function(childProcess, options, callback) {
  var check, force, onExit, ref, retryDelay, start, t, terminated, timeout;
  if (options == null) {
    options = {};
  }
  if (typeof options === 'function') {
    ref = [options, {}], callback = ref[0], options = ref[1];
  }
  force = options.force || false;
  timeout = options.timeout != null ? options.timeout : TERM_DEFAULT_TIMEOUT_MS;
  retryDelay = options.retryDelay != null ? options.retryDelay : TERM_DEFAULT_RETRY_MS;
  terminated = false;
  onExit = function() {
    terminated = true;
    return childProcess.removeListener('exit', onExit);
  };
  childProcess.on('exit', onExit);
  start = Date.now();
  t = void 0;
  check = function() {
    if (terminated) {
      clearTimeout(t);
      return callback();
    } else {
      if ((Date.now() - start) < timeout) {
        return signalTerm(childProcess, function(err) {
          if (err) {
            return callback(err);
          }
          return t = setTimeout(check, retryDelay);
        });
      } else {
        clearTimeout(t);
        if (force) {
          return signalKill(childProcess, callback);
        } else {
          return callback(new Error("Unable to gracefully terminate process " + childProcess.pid));
        }
      }
    }
  };
  return signalTerm(childProcess, function(err) {
    if (err) {
      return callback(err);
    }
    return t = setTimeout(check, TERM_FIRST_CHECK_TIMEOUT_MS);
  });
};

spawn = function() {
  var args, childProcess, killedIntentionally, terminatedIntentionally;
  args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
  childProcess = crossSpawn.spawn.apply(null, args);
  childProcess.terminated = false;
  killedIntentionally = false;
  terminatedIntentionally = false;
  childProcess.on('signalKill', function() {
    return killedIntentionally = true;
  });
  childProcess.on('signalTerm', function() {
    return terminatedIntentionally = true;
  });
  childProcess.signalKill = function() {
    return signalKill(childProcess, function(err) {
      if (err) {
        return childProcess.emit('error', err);
      }
    });
  };
  childProcess.signalTerm = function() {
    return signalTerm(childProcess, function(err) {
      if (err) {
        return childProcess.emit('error', err);
      }
    });
  };
  childProcess.terminate = function(options) {
    return terminate(childProcess, options, function(err) {
      if (err) {
        return childProcess.emit('error', err);
      }
    });
  };
  childProcess.on('exit', function(exitStatus, signal) {
    childProcess.terminated = true;
    childProcess.killedIntentionally = killedIntentionally;
    childProcess.terminatedIntentionally = terminatedIntentionally;
    if (!killedIntentionally && !terminatedIntentionally) {
      if (signal === 'SIGKILL') {
        return childProcess.emit('crash', null, true);
      } else if (exitStatus !== 0) {
        return childProcess.emit('crash', exitStatus, false);
      }
    }
  });
  return childProcess;
};

module.exports = {
  signalKill: signalKill,
  signalTerm: signalTerm,
  terminate: terminate,
  spawn: spawn
};
